% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/party.R, R/rpart.R, R/tidytrees.R
\name{tidy_tree.party}
\alias{tidy_tree.party}
\alias{tidy_tree.rpart}
\alias{tidy_tree}
\title{Turn a classification/regression tree object into a tidy tibble}
\usage{
\method{tidy_tree}{party}(
  tree,
  rule_as_text = TRUE,
  eval_ready = FALSE,
  simplify_rules = FALSE,
  add_estimates = TRUE,
  add_interval = FALSE,
  interval_level = 0.95,
  est_fun = tidytrees::get_pred_estimates
)

\method{tidy_tree}{rpart}(
  tree,
  rule_as_text = TRUE,
  eval_ready = FALSE,
  simplify_rules = FALSE,
  add_estimates = TRUE,
  add_interval = FALSE,
  interval_level = 0.95,
  est_fun = tidytrees::get_pred_estimates
)

tidy_tree(
  tree,
  rule_as_text = TRUE,
  eval_ready = FALSE,
  simplify_rules = FALSE,
  add_estimates = TRUE,
  add_interval = FALSE,
  interval_level = 0.95,
  est_fun = tidytrees::get_pred_estimates
)
}
\arguments{
\item{tree}{A tree object.}

\item{rule_as_text}{Whether to represent the rules as a string or a vector.}

\item{eval_ready}{Converts the rules into R compatible logical expressions
ready to use for data filtering purposes. If \code{FALSE}, the rules are kept as
originally defined in each class.}

\item{simplify_rules}{Keep the minimal set of conditions to identify a
node in the tree.}

\item{add_estimates}{Add predicted values at each node, as computed by the
function passed to \code{est_fun}.}

\item{add_interval}{Logical indicating whether or not to include an
estimation interval, as computed by \code{est_fun} in the tidied output.
Defaults to \code{FALSE}.}

\item{interval_level}{The interval level to use for the estimation interval
if \code{add_interval = TRUE}. Must be strictly greater than 0 and less than 1.
Defaults to 0.95.}

\item{est_fun}{Function to estimate node predictions and intervals. Must
expose three mandatory arguments: \code{values} which receive the observations
in a node, and \code{add_interval} and \code{interval_level} which get inherited from
\code{tidy_tree()}. Check \code{\link{get_pred_estimates}} as a prototype.}

\item{...}{Method specific arguments. Not used at the moment.}
}
\value{
A tibble with a row for each node with its identifying rule, the node
id (as stored in the tree object), the number of observations related to
the node, whether the node is terminal (a leaf), and the node depth. The
depth is counted starting from the children of the root node which are
considered at depth 1. The root node is ignored in the output. If
\code{add_estimates = TRUE}, prediction estimates (optionally with intervals)
are added to each node, as defined by the function passed to the \code{est_fun}
argument.
}
\description{
Takes a classification/regression tree (usually a list) and returns a
\code{\link[tibble:tibble]{tibble::tibble()}} with a row for each node including the set of additive
rules necessary to identify it. Furthermore, node characteristics and fit
details are described. Check \link{https://github.com/bakaburg1/tidytrees} for a
more detailed explanation.
}
\section{Methods (by class)}{
\itemize{
\item \code{party}: Turns a classification/regression tree produced by
\code{\link[partykit:ctree]{partykit::ctree()}} into a tidy tibble. Also trees of class
\code{\link[XML:XMLNode]{XML::XMLNode}} and \code{\link[RWeka:Weka_tree]{RWeka::Weka_tree}} can be processed after conversion
with \code{partykit::as.party()} (but results have not been tested yet).

\item \code{rpart}: Turn a classification/regression tree produced by
\code{\link[rpart:rpart]{rpart::rpart()}} into a tidy tibble. At the moment, only the \code{anova} and
\code{class} methods are fully supported: other methods may work but users need
to ensure that the fit details are correct.
}}

\examples{

tree <- rpart(iris$Sepal.Length ~ iris$Species)

tidy_tree(mod)

## Adding confidence intervals

tidy_tree(mod, add_interval = TRUE)

## Simplify rules to remove redundant conditions

tree <- ctree(Sepal.Length ~ Species + Sepal.Width, iris)
tidy_tree(simplify_rules = TRUE)

}
